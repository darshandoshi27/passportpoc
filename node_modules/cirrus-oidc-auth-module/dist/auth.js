"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.authenticate = exports.authMiddleware = exports.discoverIssuerWithRetries = exports.ignore = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _accept = _interopRequireDefault(require("accept"));

var _bodyParser = _interopRequireDefault(require("body-parser"));

var _connectEnsureLogin = require("connect-ensure-login");

var _openidClient = require("openid-client");

var _passport = _interopRequireDefault(require("passport"));

var log = _interopRequireWildcard(require("./logger"));

var _sessions = _interopRequireDefault(require("./sessions"));

var _openidVars = _interopRequireDefault(require("./openid-vars"));

var AUTH_ENABLED = process.env.AUTH_ENABLED === 'true';
var OPENID_SCOPE = process.env.OPENID_SCOPE || 'openid';
var OPENID_CALLBACK = process.env.OPENID_CALLBACK || '/auth/callback';
var useridEndpoint = process.env.USERID_ENDPOINT || '/auth/userid';
var REFRESH_WINDOW = +(process.env.REFRESH_WINDOW || '300');
var ensureLogin = (0, _connectEnsureLogin.ensureLoggedIn)();
var OPENID_ISSUER = _openidVars["default"];
var client;

if (Number.isNaN(REFRESH_WINDOW)) {
  log.error('The REFRESH_WINDOW environment variable could not be coerced to a number.');
  log.warn('The process will now exit.');
  process.exit(1);
}

log.info('Using openid-connect auth v4.0.6');

if (!AUTH_ENABLED) {
  log.warn('Authentication is off. To enable set AUTH_ENABLED to true in .env');
}

var requiredEnvVars = ['OPENID_CLIENT_ID', 'OPENID_CLIENT_SECRET', 'REDIS_URL', 'REDIS_SECRET']; // check that all environment variables are present

var missingVars = requiredEnvVars.reduce(function (acc, cur) {
  if (!process.env[cur]) acc.push(cur);
  return acc;
}, []); // if there are missing environment variables, log them

if (missingVars.length > 0) {
  log.error('The following environment variables are missing!');
  log.error("\n -- ".concat(missingVars.join('\n -- ')));
  log.error('Please note variables are CASE SENSITIVE.'); // die if env vars are missing

  log.warn('The process will now exit.');
  process.exit(1);
}

var ignoredRoutes = [];

var ignore = function ignore() {
  if (Array.isArray(arguments.length <= 0 ? undefined : arguments[0])) {
    ignoredRoutes.push.apply(ignoredRoutes, (0, _toConsumableArray2["default"])(arguments.length <= 0 ? undefined : arguments[0]));
  } else {
    ignoredRoutes.push.apply(ignoredRoutes, arguments);
  }

  log.info('The following routes are ignored: ');
  log.info(ignoredRoutes.join(' '));
  return ignoredRoutes;
};

exports.ignore = ignore;

_passport["default"].serializeUser(function (user, cb) {
  cb(null, user);
});

_passport["default"].deserializeUser(function (user, cb) {
  cb(null, user);
});
/**
 * Function to discover the openid issuer, with retries.
 * the Issuer.discover function exposed by openid-client will break
 * if the issuer is not discovered. This custom function will retry
 * a specified number of times before failing, avoiding crashing
 * when there is a small network hiccup. The try/catch block is necessary
 * because if a non-url is passed to Issuer.discover, it will break
 */


var discoverIssuerWithRetries = function discoverIssuerWithRetries() {
  var retries,
      _args2 = arguments;
  return _regenerator["default"].async(function discoverIssuerWithRetries$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          retries = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : 5;
          return _context2.abrupt("return", new Promise(function (resolve, reject) {
            try {
              _openidClient.Issuer.discover(OPENID_ISSUER).then(function (openidIssuer) {
                log.info("Discovered issuer: ".concat(OPENID_ISSUER));
                resolve(openidIssuer);
              })["catch"](function _callee() {
                var openidIssuer;
                return _regenerator["default"].async(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        if (retries <= 0) {
                          log.error('Could not discover OpenID issuer!');
                          reject(new Error('Could not discover OpenID issuer'));
                        } else {
                          log.info('Could not discover OpenID issuer, retrying...');
                          openidIssuer = discoverIssuerWithRetries(retries - 1);
                          resolve(openidIssuer);
                        }

                      case 1:
                      case "end":
                        return _context.stop();
                    }
                  }
                });
              });
            } catch (e) {
              log.error(e);
              log.error("Could not discover issuer: ".concat(OPENID_ISSUER));
              log.error('Check the URL is correct and that there is Internet connectivity');
              log.error('The process will now exit.');
              process.exit(1);
            }
          }));

        case 2:
        case "end":
          return _context2.stop();
      }
    }
  });
};
/**
 * middleware that authenticates the express router
 * @param  {Object}   req  request object from express router
 * @param  {Object}   res  response object from express router
 * @param  {Function} next function to move on to the next bit of middleware
 */


exports.discoverIssuerWithRetries = discoverIssuerWithRetries;

var authMiddleware = function authMiddleware(req, res, next) {
  var tokenWasAbleToBeRefreshed, user, expDate, now, diff, mediaTypes;
  return _regenerator["default"].async(function authMiddleware$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          tokenWasAbleToBeRefreshed = true;

          if (!(!!req.session.passport && !!req.session.passport.user && !!req.session.passport.user.refresh_token)) {
            _context3.next = 11;
            break;
          }

          user = req.session.passport.user;
          log.info("refresh token found! ".concat(user.refresh_token));
          expDate = new Date(+user.expires_at * 1000);
          now = new Date();
          diff = Math.trunc((expDate - now) / 1000);

          if (!(diff < REFRESH_WINDOW)) {
            _context3.next = 11;
            break;
          }

          log.info('Refresh flow invoked');
          _context3.next = 11;
          return _regenerator["default"].awrap(client.refresh(user.refresh_token).then(function (tokenSet) {
            log.success('Refresh token get. Applying to session');
            Object.assign(user, tokenSet);
          })["catch"](function () {
            log.error('Could not refresh token. Destroying session.');
            req.session.destroy();
            tokenWasAbleToBeRefreshed = false;
          }));

        case 11:
          if (tokenWasAbleToBeRefreshed) {
            _context3.next = 19;
            break;
          }

          mediaTypes = _accept["default"].mediaTypes(req.headers.accept);

          if (!mediaTypes.includes('text/html')) {
            _context3.next = 15;
            break;
          }

          return _context3.abrupt("return", res.redirect(req.originalUrl || '/'));

        case 15:
          if (!mediaTypes.includes('application/json')) {
            _context3.next = 18;
            break;
          }

          res.status(403);
          return _context3.abrupt("return", res.send({
            status: '403',
            error: 'no longer authenticated'
          }));

        case 18:
          return _context3.abrupt("return", res.status(403));

        case 19:
          if (!(!AUTH_ENABLED || ignoredRoutes.includes(req.path))) {
            _context3.next = 23;
            break;
          }

          // pass through to next request
          log.info("Serving ".concat(req.path, " to verified user"));
          Object.keys(req.query || {}).filter(function (key) {
            return key !== 'id_token';
          }).forEach(function (key) {
            return log.info("Param ".concat(key, ": ").concat(req.query[key]));
          });
          return _context3.abrupt("return", next());

        case 23:
          return _context3.abrupt("return", ensureLogin(req, res, next));

        case 24:
        case "end":
          return _context3.stop();
      }
    }
  });
};

exports.authMiddleware = authMiddleware;

var authenticate = function authenticate(router) {
  var openidIssuer, params;
  return _regenerator["default"].async(function authenticate$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          /*
            When on Heroku, 'trust proxy' must be
            set to forward important connection information.
          */
          router.set('trust proxy', true);
          router.use(_bodyParser["default"].json());
          router.use(_bodyParser["default"].urlencoded({
            extended: true
          })); // set the router/app up with redis session storage

          (0, _sessions["default"])(router);
          router.use(_passport["default"].initialize());
          router.use(_passport["default"].session());
          router.use('/login', function (req, res, next) {
            log.info('Serving /login');
            var redirectUri = "".concat(req.protocol, "://").concat(req.get('host')).concat(OPENID_CALLBACK);
            var state = req.originalUrl;
            return _passport["default"].authenticate('oidc', {
              redirect_uri: redirectUri,
              state: state
            })(req, res, next);
          }, function (req, res) {
            res.redirect(req.originalUrl || '/');
          });
          router.use(OPENID_CALLBACK, function (req, res, next) {
            log.info("Serving ".concat(OPENID_CALLBACK));
            var redirectUri = "".concat(req.protocol, "://").concat(req.get('host')).concat(OPENID_CALLBACK);

            if (req.query.code) {
              var successRedirect = req.session.returnTo || '/';
              return _passport["default"].authenticate('oidc', {
                successRedirect: successRedirect,
                failureRedirect: '/',
                redirect_uri: redirectUri
              })(req, res, next);
            }

            return res.redirect('/');
          });
          router.get(useridEndpoint, function (req, res) {
            log.info("Serving ".concat(useridEndpoint));
            var userid = (req.user || {}).sub || 'no-authenticated-user';
            log.info("userid: ".concat(userid));
            res.json({
              userid: userid,
              auth_set: AUTH_ENABLED,
              user_authed: !!req.user
            });
          });
          router.get('/logout', function (req, res) {
            log.info('Serving /logout');
            req.session.destroy();
            res.send('signed out');
          }); // use our auth middleware AFTER authentication flow routes
          // so unauthenticated users can access auth flow

          router.use(authMiddleware);
          /* istanbul ignore next */

          _context4.next = 13;
          return _regenerator["default"].awrap(discoverIssuerWithRetries()["catch"](function () {
            log.error("Could not discover issuer: ".concat(OPENID_ISSUER));
            log.error('Check that you have spelled the URL correctly,' + ' and that the internet is up.');
            log.error('The process will now exit.');
            process.exit(1);
          }));

        case 13:
          openidIssuer = _context4.sent;
          client = new openidIssuer.Client({
            client_id: process.env.OPENID_CLIENT_ID,
            client_secret: process.env.OPENID_CLIENT_SECRET
          });

          client[_openidClient.custom.http_options] = function (options) {
            options.timeout = 10000;
            return options;
          };

          params = {
            response_type: 'code',
            scope: OPENID_SCOPE,
            response_mode: 'query'
          };

          _passport["default"].use('oidc', new _openidClient.Strategy({
            client: client,
            params: params
          }, function (tokenset, done) {
            tokenset.claims = tokenset.claims();
            tokenset.sub = tokenset.claims.sub;

            if (tokenset.claims.uid) {
              log.info("User has been authenticated: ".concat(tokenset.claims.uid));
            } else {
              log.info("User has been authenticated: ".concat(tokenset.claims.sub));
            }

            return done(null, tokenset);
          }));

          return _context4.abrupt("return", router);

        case 19:
        case "end":
          return _context4.stop();
      }
    }
  });
};

exports.authenticate = authenticate;
//# sourceMappingURL=auth.js.map
