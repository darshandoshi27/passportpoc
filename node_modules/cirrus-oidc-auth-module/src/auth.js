import Accept from 'accept';
import bodyParser from 'body-parser';
import { ensureLoggedIn } from 'connect-ensure-login';
import { Strategy, Issuer, custom } from 'openid-client';
import passport from 'passport';
import * as log from './logger';
import session from './sessions';
import issuer from './openid-vars';

const AUTH_ENABLED = process.env.AUTH_ENABLED === 'true';
const OPENID_SCOPE = process.env.OPENID_SCOPE || 'openid';
const OPENID_CALLBACK = process.env.OPENID_CALLBACK || '/auth/callback';
const useridEndpoint = process.env.USERID_ENDPOINT || '/auth/userid';
const REFRESH_WINDOW = +(process.env.REFRESH_WINDOW || '300');
const ensureLogin = ensureLoggedIn();
const OPENID_ISSUER = issuer;
let client;

if (Number.isNaN(REFRESH_WINDOW)) {
  log.error(
    'The REFRESH_WINDOW environment variable could not be coerced to a number.',
  );
  log.warn('The process will now exit.');
  process.exit(1);
}

log.info('Using openid-connect auth v4.0.6');

if (!AUTH_ENABLED) {
  log.warn('Authentication is off. To enable set AUTH_ENABLED to true in .env');
}

const requiredEnvVars = [
  'OPENID_CLIENT_ID',
  'OPENID_CLIENT_SECRET',
  'REDIS_URL',
  'REDIS_SECRET',
];

// check that all environment variables are present
const missingVars = requiredEnvVars.reduce((acc, cur) => {
  if (!process.env[cur]) acc.push(cur);
  return acc;
}, []);

// if there are missing environment variables, log them
if (missingVars.length > 0) {
  log.error('The following environment variables are missing!');
  log.error(`\n -- ${missingVars.join('\n -- ')}`);
  log.error('Please note variables are CASE SENSITIVE.');
  // die if env vars are missing
  log.warn('The process will now exit.');
  process.exit(1);
}

const ignoredRoutes = [];

export const ignore = (...ignoredRoutesIn) => {
  if (Array.isArray(ignoredRoutesIn[0])) {
    ignoredRoutes.push(...ignoredRoutesIn[0]);
  } else {
    ignoredRoutes.push(...ignoredRoutesIn);
  }

  log.info('The following routes are ignored: ');
  log.info(ignoredRoutes.join(' '));

  return ignoredRoutes;
};

passport.serializeUser((user, cb) => {
  cb(null, user);
});

passport.deserializeUser((user, cb) => {
  cb(null, user);
});

/**
 * Function to discover the openid issuer, with retries.
 * the Issuer.discover function exposed by openid-client will break
 * if the issuer is not discovered. This custom function will retry
 * a specified number of times before failing, avoiding crashing
 * when there is a small network hiccup. The try/catch block is necessary
 * because if a non-url is passed to Issuer.discover, it will break
 */
export const discoverIssuerWithRetries = async (retries = 5) => new Promise((resolve, reject) => {
  try {
    Issuer.discover(OPENID_ISSUER).then((openidIssuer) => {
      log.info(`Discovered issuer: ${OPENID_ISSUER}`);
      resolve(openidIssuer);
    }).catch(async () => {
      if (retries <= 0) {
        log.error('Could not discover OpenID issuer!');
        reject(new Error('Could not discover OpenID issuer'));
      } else {
        log.info('Could not discover OpenID issuer, retrying...');
        const openidIssuer = discoverIssuerWithRetries(retries - 1);
        resolve(openidIssuer);
      }
    });
  } catch (e) {
    log.error(e);
    log.error(`Could not discover issuer: ${OPENID_ISSUER}`);
    log.error('Check the URL is correct and that there is Internet connectivity');
    log.error('The process will now exit.');
    process.exit(1);
  }
});

/**
 * middleware that authenticates the express router
 * @param  {Object}   req  request object from express router
 * @param  {Object}   res  response object from express router
 * @param  {Function} next function to move on to the next bit of middleware
 */
export const authMiddleware = async (req, res, next) => {
  let tokenWasAbleToBeRefreshed = true;

  if (!!req.session.passport && !!req.session.passport.user
    && !!req.session.passport.user.refresh_token) {
    const { user } = req.session.passport;
    log.info(`refresh token found! ${user.refresh_token}`);
    const expDate = new Date((+user.expires_at) * 1000);
    const now = new Date();
    const diff = Math.trunc((expDate - now) / 1000);

    if (diff < REFRESH_WINDOW) {
      log.info('Refresh flow invoked');
      await client.refresh(user.refresh_token)
        .then((tokenSet) => {
          log.success('Refresh token get. Applying to session');
          Object.assign(user, tokenSet);
        })
        .catch(() => {
          log.error('Could not refresh token. Destroying session.');
          req.session.destroy();
          tokenWasAbleToBeRefreshed = false;
        });
    }
  }

  if (!tokenWasAbleToBeRefreshed) {
    const mediaTypes = Accept.mediaTypes(req.headers.accept);

    if (mediaTypes.includes('text/html')) {
      return res.redirect(req.originalUrl || '/');
    } if (mediaTypes.includes('application/json')) {
      res.status(403);
      return res.send({ status: '403', error: 'no longer authenticated' });
    }

    return res.status(403);
  }

  // allow a user through if we've disabled auth or they've ignored a route
  if (!AUTH_ENABLED || ignoredRoutes.includes(req.path)) {
    // pass through to next request
    log.info(`Serving ${req.path} to verified user`);

    Object.keys(req.query || {})
      .filter((key) => key !== 'id_token')
      .forEach((key) => log.info(`Param ${key}: ${req.query[key]}`));

    return next();
  }

  return ensureLogin(req, res, next);
};

export const authenticate = async (router) => {
  /*
    When on Heroku, 'trust proxy' must be
    set to forward important connection information.
  */
  router.set('trust proxy', true);

  router.use(bodyParser.json());
  router.use(bodyParser.urlencoded({ extended: true }));
  // set the router/app up with redis session storage
  session(router);

  router.use(passport.initialize());
  router.use(passport.session());

  router.use('/login', (req, res, next) => {
    log.info('Serving /login');
    const redirectUri = `${req.protocol}://${req.get('host')}${OPENID_CALLBACK}`;

    const state = req.originalUrl;

    return passport.authenticate(
      'oidc',
      { redirect_uri: redirectUri, state },
    )(req, res, next);
  },
  (req, res) => {
    res.redirect(req.originalUrl || '/');
  });

  router.use(OPENID_CALLBACK, (req, res, next) => {
    log.info(`Serving ${OPENID_CALLBACK}`);
    const redirectUri = `${req.protocol}://${req.get('host')}${OPENID_CALLBACK}`;
    if (req.query.code) {
      const successRedirect = req.session.returnTo || '/';

      return passport.authenticate(
        'oidc',
        { successRedirect, failureRedirect: '/', redirect_uri: redirectUri },
      )(req, res, next);
    }

    return res.redirect('/');
  });

  router.get(useridEndpoint, (req, res) => {
    log.info(`Serving ${useridEndpoint}`);
    const userid = (req.user || {}).sub || 'no-authenticated-user';
    log.info(`userid: ${userid}`);
    res.json({
      userid,
      auth_set: AUTH_ENABLED,
      user_authed: !!req.user,
    });
  });

  router.get('/logout', (req, res) => {
    log.info('Serving /logout');
    req.session.destroy();
    res.send('signed out');
  });

  // use our auth middleware AFTER authentication flow routes
  // so unauthenticated users can access auth flow
  router.use(authMiddleware);

  /* istanbul ignore next */
  const openidIssuer = await discoverIssuerWithRetries()
    .catch(() => {
      log.error(`Could not discover issuer: ${OPENID_ISSUER}`);
      log.error('Check that you have spelled the URL correctly,'
        + ' and that the internet is up.');
      log.error('The process will now exit.');
      process.exit(1);
    });

  client = new openidIssuer.Client({
    client_id: process.env.OPENID_CLIENT_ID,
    client_secret: process.env.OPENID_CLIENT_SECRET,
  });
  client[custom.http_options] = (options) => {
    options.timeout = 10000;
    return options;
  };
  const params = {
    response_type: 'code',
    scope: OPENID_SCOPE,
    response_mode: 'query',
  };

  passport.use(
    'oidc',
    new Strategy({ client, params },
      (tokenset, done) => {
        tokenset.claims = tokenset.claims();
        tokenset.sub = tokenset.claims.sub;
        if (tokenset.claims.uid) {
          log.info(`User has been authenticated: ${tokenset.claims.uid}`);
        } else {
          log.info(`User has been authenticated: ${tokenset.claims.sub}`);
        }
        return done(null, tokenset);
      }),
  );

  return router;
};
