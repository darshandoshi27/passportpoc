process.env.AUTH_ENABLED = true;
process.env.ENABLE_AUTH_LOGGING = true;
process.env.OPENID_CLIENT_ID = 'sample-clientid';
process.env.OPENID_CLIENT_SECRET = 'sample-secret';
process.env.OPENID_SCOPE = 'openid profile email offline_access';
process.env.REDIS_URL = 'redis://localhost';
process.env.REDIS_SECRET = 'redis-secret';

const { ensureLoggedIn } = require('connect-ensure-login');
const MockStrategy = require('passport-mock-strategy');
const session = require('supertest-session');
const passport = require('passport');
const request = require('supertest');
const express = require('express');
const redis = require('redis');
const redisMock = require('redis-mock');
const sinon = require('sinon');
const url = require('url');
const { expect } = require('chai');

sinon.replace(redis, 'createClient', redisMock.createClient);

const Session = require('express-session/session/session');
const { createSessionOpts, serializer } = require('../dist/sessions');
const auth = require('../dist/auth');
const log = require('../dist/logger');
require('./mock-federate');

const app = express();
const agent = request.agent(app);

describe('Logging framework', () => {
  beforeEach(() => {
    sinon.spy(console, 'log');
  });

  afterEach(() => {
    console.log.restore();
  });

  describe('logs when logging is enabled', () => {
    it('should be able to log with .error', () => {
      log.error('test log.error');
      expect(console.log.getCall(0).args[0]).to.have.string('test log.error');
    });

    it('should be able to log with .warn', () => {
      log.warn('test log.warn');
      expect(console.log.getCall(0).args[0]).to.have.string('test log.warn');
    });

    it('should be able to log with .success', () => {
      log.success('test log.success');
      expect(console.log.getCall(0).args[0]).to.have.string('test log.success');
    });

    it('should be able to log with .info', () => {
      log.info('test log.info');
      expect(console.log.getCall(0).args[0]).to.have.string('test log.info');
    });

    it('should be able to log with .plain', () => {
      log.plain('test log.plain');
      expect(console.log.getCall(0).args[0]).to.have.string('test log.plain');
    });
  });

  describe('no log when logging is disabled', () => {
    let log2;

    /*
     * Remove the log package from the require cache and re-require it
     * this will cause the code inside to be re-ran so we can verify that
     * the ENABLE_AUTH_LOGGING variable works properly.
     */
    before(() => {
      delete require.cache[require.resolve('../dist/logger')];
      process.env.ENABLE_AUTH_LOGGING = false;
      log2 = require('../dist/logger');
    });

    it('should not log with .error', () => {
      log2.error('test log.error');
      expect(console.log.called).to.equal(false);
    });

    it('should not log with .warn', () => {
      log2.warn('test log.warn');
      expect(console.log.called).to.equal(false);
    });

    it('should not log with .success', () => {
      log2.success('test log.success');
      expect(console.log.called).to.equal(false);
    });

    it('should not log with .info', () => {
      log2.info('test log.info');
      expect(console.log.called).to.equal(false);
    });

    it('should not log with .plain', () => {
      log2.plain('test log.plain');
      expect(console.log.called).to.equal(false);
    });
  });
});

describe('createSessionOpts', () => {
  describe('saveUninitialized', () => {
    it('should set a default saveUninitialized if not present', () => {
      expect(createSessionOpts({}).saveUninitialized).to.equal(false);
    });

    it('should allow the user to configure saveUninitialized', () => {
      expect(createSessionOpts({ SESSION_SAVE_UNINITIALIZED: 'true' }).saveUninitialized).to.equal(true);
    });
  });

  describe('resave', () => {
    it('should set a default resave if not present', () => {
      expect(createSessionOpts({}).resave).to.equal(false);
    });

    it('should allow the user to configure resave', () => {
      expect(createSessionOpts({ SESSION_RESAVE: 'true' }).resave).to.equal(true);
    });
  });

  describe('secret', () => {
    it('should set a default secret if not present', () => {
      expect(createSessionOpts({}).secret).to.be.a('string');
      expect(createSessionOpts({}).secret).to.have.lengthOf(36);
    });

    it('should allow the user to configure secret', () => {
      expect(createSessionOpts({ COOKIE_SECRET: 'secret_code' }).secret).to.equal('secret_code');
    });
  });

  describe('name', () => {
    it('should set a default name if not present', () => {
      expect(createSessionOpts({}).name).to.equal('lilly.id');
    });

    it('should allow the user to configure name', () => {
      expect(createSessionOpts({ SESSION_COOKIE_NAME: 'express.id' }).name).to.equal('express.id');
    });
  });

  describe('cookie.httpOnly', () => {
    it('should set a default cookie.httpOnly if not present', () => {
      expect(createSessionOpts({}).cookie.httpOnly).to.equal(true);
    });

    it('should allow the user to configure cookie.httpOnly', () => {
      expect(createSessionOpts({ SESSION_COOKIE_HTTP_ONLY: 'false' }).cookie.httpOnly).to.equal(false);
    });
  });

  describe('cookie.maxAge', () => {
    it('should set a default cookie.maxAge if not present', () => {
      expect(createSessionOpts({}).cookie.maxAge).to.equal(1800000);
    });

    it('should allow the user to configure cookie.maxAge', () => {
      expect(createSessionOpts({ SESSION_COOKIE_MAX_AGE: '12345' }).cookie.maxAge).to.equal(12345);
    });
  });

  describe('cookie.path', () => {
    it('should set a default cookie.path if not present', () => {
      expect(createSessionOpts({}).cookie.path).to.equal('/');
    });

    it('should allow the user to configure cookie.path', () => {
      expect(createSessionOpts({ SESSION_COOKIE_PATH: '/myapp/' }).cookie.path).to.equal('/myapp/');
    });
  });

  describe('cookie.sameSite', () => {
    it('should set a default cookie.sameSite if not present', () => {
      expect(createSessionOpts({}).cookie.sameSite).to.equal(undefined);
    });

    it('should allow the user to configure cookie.sameSite', () => {
      expect(createSessionOpts({ SESSION_COOKIE_SAME_SITE: 'strict' }).cookie.sameSite).to.equal('strict');
    });
  });

  describe('cookie.secure', () => {
    it('should set a default cookie.secure if not present', () => {
      expect(createSessionOpts({}).cookie.secure).to.equal(undefined);
    });

    it('should allow the user to configure cookie.secure', () => {
      expect(createSessionOpts({ SESSION_COOKIE_SECURE: 'true' }).cookie.secure).to.equal(true);
    });
  });

  describe('proxy', () => {
    it('should set a default proxy if not present', () => {
      expect(createSessionOpts({}).proxy).to.equal(undefined);
    });

    it('should allow the user to configure proxy', () => {
      expect(createSessionOpts({ SESSION_PROXY: 'true' }).proxy).to.equal(true);
    });
  });

  describe('rolling', () => {
    it('should set a default rolling if not present', () => {
      expect(createSessionOpts({}).rolling).to.equal(false);
    });

    it('should allow the user to configure rolling', () => {
      expect(createSessionOpts({ SESSION_ROLLING: 'true' }).rolling).to.equal(true);
    });
  });

  describe('unset', () => {
    it('should set a default unset if not present', () => {
      expect(createSessionOpts({}).unset).to.equal('keep');
    });

    it('should allow the user to configure unset', () => {
      expect(createSessionOpts({ SESSION_UNSET: 'destroy' }).unset).to.equal('destroy');
    });
  });
});

describe('Cirrus Auth Module', () => {
  describe('#authenticate', () => {
    it('should exist', () => {
      expect(auth.authenticate).to.not.equal(undefined);
    });

    it('should add middleware to express', async () => {
      sinon.spy(app, 'use');
      await auth.authenticate(app);

      expect(app.use.calledWith(auth.authMiddleware)).to.equal(true);
      app.use.restore();
    });
  });

  describe('#ignore', () => {
    it('should accept an array as a parameter', () => {
      const returned = auth.ignore(['test', 'one', 'two']);

      expect(returned.indexOf('test')).to.not.equal(-1);
      expect(returned.indexOf('one')).to.not.equal(-1);
      expect(returned.indexOf('two')).to.not.equal(-1);
    });

    it('should accept multiple parameters', () => {
      const returned = auth.ignore('foo', 'bar', 'baz');

      expect(returned.indexOf('foo')).to.not.equal(-1);
      expect(returned.indexOf('bar')).to.not.equal(-1);
      expect(returned.indexOf('baz')).to.not.equal(-1);
    });
  });

  describe('#authMiddleware', () => {
    it('should invoke next() if path is in ignored routes', async () => {
      let invoked = false;

      auth.ignore('/ignored');

      const ensureLogin = ensureLoggedIn();

      const req = { session: {}, path: '/ignored' };
      const res = {};
      const next = () => invoked = true;

      await auth.authMiddleware(req, res, next);

      const spy = sinon.spy(ensureLogin);

      expect(invoked).to.equal(true);
      expect(spy.called).to.equal(false);
    });

    it('should not redirect an authenticated user', async () => {
      let redirected = false;

      const req = { session: { isAuthed: true }, originalUrl: '/', isAuthenticated: () => true };
      const res = { redirect: () => redirected = true };

      await auth.authMiddleware(req, res, () => {});

      expect(redirected).to.equal(false);
    });

    it('should redirect an unauthenticated user to the login page', async () => {
      let redirected = false;

      const req = { session: { }, originalUrl: '/' };
      const res = {
        redirect: () => {
          redirected = true;
        },
      };

      await auth.authMiddleware(req, res, () => {});

      expect(redirected).to.equal(true);
    });

    it('should invoke the refresh flow if cookie is set to expire', async () => {
      let redirected = false;

      const req = {
        session: { passport: { user: { expires_at: (Date.now() / 1000), refresh_token: 'original_token' } } },
        originalUrl: '/',
        isAuthenticated: () => true,
      };
      const res = { redirect: () => redirected = true };

      await auth.authMiddleware(req, res, () => {});

      expect(redirected).to.equal(false);
      expect(req.session.passport.user.refresh_token).to.equal('refreshed_token');
    });

    it('should not invoke the refresh flow if cookie is not set to expire', async () => {
      let redirected = false;

      const req = {
        session: { passport: { user: { expires_at: (Date.now() / 1000) + 1000, refresh_token: 'original_token' } } },
        originalUrl: '/',
        isAuthenticated: () => true,
      };
      const res = { redirect: () => redirected = true };

      await auth.authMiddleware(req, res, () => {});

      expect(redirected).to.equal(false);
      expect(req.session.passport.user.refresh_token).to.equal('original_token');
    });

    it('should destroy session and re-auth the user if their token cannot be refreshed', async () => {
      let redirectedTo = '';
      let destroyCalled = false;

      const req = {
        session: {
          passport: { user: { expires_at: (Date.now() / 1000), refresh_token: 'original_token' } },
          destroy: () => destroyCalled = true,
        },
        headers: {
          accept: 'text/html',
        },
        originalUrl: '/sample-url/',
        isAuthenticated: () => true,
      };

      const res = {
        redirect: (toUrl) => redirectedTo = toUrl,
      };

      await auth.authMiddleware(req, res, () => {});

      expect(destroyCalled).to.equal(true);
      expect(redirectedTo).to.equal('/sample-url/');
    });

    it('should respond with 403 for bad tokens if the client doesn\'t support text/html', async () => {
      let destroyCalled = false;
      let statusCode = 0;
      let data = {};

      const req = {
        session: {
          passport: { user: { expires_at: (Date.now() / 1000), refresh_token: 'original_token' } },
          destroy: () => destroyCalled = true,
        },
        headers: {
          accept: 'application/json',
        },
        originalUrl: '/sample-url/',
        isAuthenticated: () => true,
      };

      const res = {
        redirect: (toUrl) => toUrl,
        status: (code) => statusCode = code,
        send: (json) => data = json,
      };

      await auth.authMiddleware(req, res, () => {});

      expect(destroyCalled).to.equal(true);
      expect(statusCode).to.equal(403);
      expect(data).to.have.own.property('error');
      expect(data.error).to.equal('no longer authenticated');
    });
  });

  describe('/auth/userid', () => {
    it('should respond with json', (done) => {
      request(app)
        .get('/auth/userid')
        .set('Accept', 'application/json')
        .expect('Content-Type', /json/)
        .expect(200)
        .then((response) => {
          expect(response.body).to.have.own.property('userid');
          done();
        });
    });
  });

  describe('/login', () => {
    let testSession;

    before(() => {
      testSession = session(app);
      redisMock.storage = {};
    });

    it('should redirect user to federation server', (done) => {
      testSession
        .get('/login')
        .expect(302)
        .then((response) => {
          const urlParts = url.parse(response.headers.location, true);
          expect(urlParts.hostname).to.equal('login.microsoftonline.com');
          expect(urlParts.query.scope).to.equal('openid profile email offline_access');
          done();
        });
    });

    it('should save user details to the session store', (done) => {
      sinon.spy(Session.prototype, 'save');

      testSession
        .get('/auth/callback?code=testing&state=%2Flogin')
        .expect(302)
        .then(() => {
          const key = Object.keys(redisMock.storage)
            .find((k) => k.startsWith('sess'));
          const { user } = serializer.parse(redisMock.storage[key].value).passport;

          expect(user.sub).to.equal('1234567890');
          expect(user.claims.sub).to.equal('1234567890');

          expect(Session.prototype.save.called).to.equal(true);
          done();
        });
    });
  });

  describe('/logout', () => {
    // mock authenticating the user to test the logout function
    before(() => {
      passport.use('oidc', new MockStrategy());

      return agent
        .get('/login');
    });

    it('should log out user and redirect to correct url', (done) => {
      sinon.spy(Session.prototype, 'destroy');

      agent
        .get('/logout')
        .expect(200)
        .then(() => {
          expect(Session.prototype.destroy.called).to.equal(true);
          done();
        });
    });
  });
});
