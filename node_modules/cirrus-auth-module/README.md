# Cirrus Authentication Module

## Table of Contents
* [Introduction](#introduction)
* [Prerequisites](#prerequisites)
* [Installation](#installation)
* [Environment Variables](#required-environment-variables)
* [Usage](#usage)
* [Endpoints](#endpoints)
* [Contributing](#contributing)
* [Setting Express up for HTTPS](#setting-express-up-for-https)
* [Migrating to Version 4](#migrating-to-version-4)

## Introduction
This module provides an _out of the box_ authentication solution for a NodeJS application running on Heroku. The code is provided as a module to enhance maintainability and also to allow developers to integrate Cirrus's authentication into their applications.

## Prerequisites

### Express.js
You will need to be using Express as your web framework. This module provides middleware for express, and thus will not work for other node web frameworks.

### .npmrc
To install this module, you need access to the Artifactory repository. To get access to this, you need a .npmrc file in the root of your project's directory. The file should look like this:

```ini
registry=https://elilillyco.jfrog.io/elilillyco/api/npm/Lilly-NPM/
_auth=YXJ0aWZhY3RvcnlAbGlzdHMubGlsbHkuY29tOkFLQ3A1YkIzY3hrdkVGRmlYQUtSU2lQZjFyV0dKV0JIZDllcHoxcEtDSlk4WWNjcDhyb2J6dm52OXV0VjhYNXN3TGFrUlY1d1A=
email=artifactory@lists.lilly.com
always-auth=true
```
**Note:** a blank space is required at the end of the auth token? Artifactory returns a 403 unless there is a blank space at the end of the auth token.

**If you are developing on the Lilly network you should configure npm with Lilly's proxy. To do this run the following commands:**
```zsh
npm config set http-proxy http://proxy.gtm.lilly.com:9000
npm config set https-proxy http://proxy.gtm.lilly.com:9000
```

## Installation
`npm install cirrus-auth-module --save`

## Environment Variables

| Environment Variable   | Required? | Default Value                            |
| ---------------------- | --------- | -----------------------------------      |
| `AUTH_TYPE`            | **Yes**   | None. See **<sup>1</sup>.**              |              

1.  either `openid-implicit` or `openid-connect`. You must then perform further configuration based on which value you choose:
  - [openid-implicit](https://github.com/EliLillyCo/CIRR_PING_AUTH_MODULE#environment-variables)
  - [openid-connect](https://github.com/EliLillyCo/CIRR_OIDC_AUTH_MODULE#environment-variables)

**Note:** You do not need to install these modules separately. This parent module will handle that for you.

### Which `AUTH_TYPE` do I use?

It is recommended that you use the [openid-connect](https://github.com/EliLillyCo/CIRR_OIDC_AUTH_MODULE) flow for most use cases. If your app needs access tokens for authenticating to a Lilly gateway, you must use `openid-connect`. The [openid-implicit](https://github.com/EliLillyCo/CIRR_PING_AUTH_MODULE) will not work. Please refer to [Cirrus Gateway Service](https://github.com/EliLillyCo/CIRR_Gateway_Service) for instructions on installing and using the module allowing applications to quickly interact with Lilly's SOA/API Gateways.

You should only use the [openid-implicit](https://github.com/EliLillyCo/CIRR_PING_AUTH_MODULE) flow for pre-production or proof of concept applications. This module will only work on Heroku.

## Usage
```js
const express = require('express');
const auth = require('cirrus-auth-module');
const app = express();

// Our port the application will listen on.
const PORT = process.env.PORT || 8080;

// call cirrus-auth-modue authenticate method on our express app
auth.authenticate(app);

app.get('/', (req, res) => {
  res.send('test');
});

app.listen(PORT, () => {
  console.log(`Server running at localhost:${PORT}`);
});
```
If you would like to exclude routes from authentication, you can make use of the `ignore()` functionality. This is useful for service workers caching items, or webhooks.

Simply pass an any number of routes to this method to have them ignored from authentication like so:

```js
const express = require('express');
const auth = require('cirrus-auth-module');
const app = express();

// Our port the application will listen on.
const PORT = process.env.PORT || 8080;

// call cirrus-auth-modue authenticate method on our express app
auth.authenticate(app);

// ignore the following routes
auth.ignore(['/public/bundle.js', '/api/contentful/hook']);

app.get('/', (req, res) => {
  res.send('test');
});

app.listen(PORT, () => {
  console.log(`Server running at localhost:${PORT}`);
});
```

## Endpoints
* GET `/auth/userid` (configured in .env as USERID_ENDPOINT)
  * Returns a JSON payload:
```json
{
  "userid": "C212345",
  "auth_set": true,
  "user_authed": true,
}
```

To get data from this endpoint, you can use the following code snippet:
```js
// NOT supported by IE. Use the fetch polyfill - https://github.com/github/fetch
const { userid } = await fetch('/auth/userid').then(resp => resp.json());

// supported by older browsers
// not recommended for use
var userid;
var xhr = new XMLHttpRequest();
xhr.open("GET", "/auth/userid");
xhr.onload = function() {
  userid = JSON.parse(this.responseText);
};
xhr.send();
```

* GET `/logout`
  * Clears auth cookies and resets the session.

## Contributing

1. Clone this repository:

```bash
git clone https://github.com/EliLillyCo/CIRR_AUTH_MODULE.git
```

2. Create a new branch with a descriptive name matching the issue:

```bash
git checkout master
git checkout -b feature/123-issue-description-here
```

3. Write a new unit test that fails without the desired functionality.

4. Make necessary code changes.

5. Run linting scripts:

```bash
npm run lint
```

6. Run your unit tests:

```bash
npm run test
```

7. Update the version number in `package.json` and `package-lock.json` and update the `CHANGELOG.md` file with your changes. This project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html) so keep that in mind when assigning your version number.

8. Push branch to GitHub and open a pull request.

9. Wait for continuous integration tests to pass (will appear as a comment in the pull request).

10. Wait for feedback.

## Setting Express up for HTTPS
Because you will not be able to develop use auth without HTTPS, this is a quickstart guide to getting HTTPS on a local express setup.

**Note**: Disabling auth will still add the userid endpoint. You may be able to skip this step.
1. Sign some certificates:
```zsh
openssl genrsa -out server-key.pem 1024
openssl req -new -key server-key.pem -out server-csr.pem
openssl x509 -req -in server-csr.pem -signkey server-key.pem -out server-cert.pem
```

2. Pull HTTPS in to your Express app
```javascript
/**
 * Pull in main requirements
 */
const express = require('express');
const https = require('https');
const http = require('http');
const fs = require('fs');
const app = express();

/**
 * Load keys from local files
 */

const key = fs.readFileSync('server-key.pem');
const cert = fs.readFileSync('server-cert.pem');
const options = { key, cert };
app.set('port', process.env.PORT || 5000);

let server;

/**
 * If we're developing locally, use https
 * If we're not, we're on heroku which we can use HTTPS for.
 */
if (process.env.NODE_ENV === 'local') {
  server = https.createServer(options, app);
} else {
  server = http.createServer(app);
}   

// listen and let us know when we're good to go!
server.listen(process.env.PORT);
server.on('listening', () => console.log(`Server listening on localhost:${process.env.PORT}`));
```
## Migrating to Version 4
See https://github.com/EliLillyCo/CIRR_OIDC_AUTH_MODULE#migrating-to-version-4

## Migrating to Version 3
(**NOTE:** This is legacy information for historical purposes only.)

As of v3.0.1, the 3.x branch supports Node 10 and Node 12. Previous versions of the 3.x branch only supported Node 12. We recommend all developers use the 3.x branch going forward, as it will receive dependency updates, bugfixes, and security fixes.


## Migrating to Version 2
(**NOTE:** This is legacy information for historical purposes only.)

Version 2 of the Cirrus Authentication Module introduces some API changes.

The user information was formerly stored in the session as `req.session.jwt`. This information is now available as `req.session.passport.user`. This is true whether you are using the `openid-implicit` flow or the `openid-connect` flow. Here is some example code:

_old version (v1.2.5)_
```js
app.use((req, res, next) => {
  console.log(`UserID: ${req.session.jwt.sub}`);
  console.log(`Access token: ${res.session.jwt.access_token}`);
  next();
})
```

_new version (v2.0.0)_
```js
app.use((req, res, next) => {
  const user = req.session.passport.user;
  console.log(`UserID: ${user.sub}`);
  console.log(`Access token: ${user.access_token}`);
  next();
})
```

### Openid-connect Flow Environment Variable Changes
Additionally, there are changes to the configuration of environment variables that are needed if you are using the `openid-connect` flow:
* `AUTH_ENABLED` is now required. This was previously defaulted to false, but that could easily mislead a user into thinking their application is being secured by authentication when it isn't.
* `REDIS_SECRET` is now required. This is a key that Redis will use to encrypt the sessions stored in it.
* `COOKIE_SECRET` is a new configuration variable. This will allow you to choose the key used to encrypt the cookie data. If left blank it will be randomly generated when the server starts. If your application is running across multiple nodes you will need to set this variable to ensure consistency.

The OpenID issuer can be configured via two methods. You can set a url to a specific value by setting the `OPENID_ISSUER` environment variable. Or you can set `PING_VERSION` to `DEV` or `PROD` to choose the dev or prod federate servers, respectively. The default if both of these values are unset is `https://federate-qa.xh1.lilly.com`.
