process.env.AUTH_ENABLED = true;
process.env.ENABLE_AUTH_LOGGING = true;
process.env.OPENID_CLIENT_ID = 'sample-clientid';

const { IncomingMessage } = require('http');
const { ensureLoggedIn } = require('connect-ensure-login');
const MockStrategy = require('passport-mock-strategy');
const session = require('supertest-session');
const passport = require('passport');
const request = require('supertest');
const express = require('express');
const sinon = require('sinon');
const path = require('path');
const url = require('url');
const fs = require('fs');
const { expect } = require('chai');

const { afterLogoutUrl, openidCallbackPath } = require('../dist/endpoints');
const auth = require('../dist/index');
const log = require('../dist/logger').default;
require('./mock-federate');

const app = express();
const agent = request.agent(app);

describe('Util.js', () => {
  describe('should warn when auth is disabled', () => {
    let util;

    /*
     * Remove the util package from the require cache and re-require it
     * this will cause the code inside to be re-ran so we can verify that
     * the AUTH_ENABLED variable works properly.
     */
    before(() => {
      delete require.cache[require.resolve('../dist/util')];
      process.env.AUTH_ENABLED = false;
      util = require('../dist/util');
    });

    it('should warn that auth is disabled', () => {
      sinon.spy(log, 'warn');
      util.checkEnvironment();
      expect(log.warn.calledWith('Auth is disabled.')).to.equal(true);
      log.warn.restore();
    });
  });
});

describe('Logging framework', () => {
  beforeEach(() => {
    sinon.spy(console, 'log');
  });

  afterEach(() => {
    console.log.restore();
  });

  describe('logs when logging is enabled', () => {
    it('should be able to log with .error', () => {
      log.error('test log.error');
      expect(console.log.getCall(0).args[0]).to.have.string('test log.error');
    });

    it('should be able to log with .warn', () => {
      log.warn('test log.warn');
      expect(console.log.getCall(0).args[0]).to.have.string('test log.warn');
    });

    it('should be able to log with .success', () => {
      log.success('test log.success');
      expect(console.log.getCall(0).args[0]).to.have.string('test log.success');
    });

    it('should be able to log with .info', () => {
      log.info('test log.info');
      expect(console.log.getCall(0).args[0]).to.have.string('test log.info');
    });

    it('should be able to log with .plain', () => {
      log.plain('test log.plain');
      expect(console.log.getCall(0).args[0]).to.have.string('test log.plain');
    });
  });

  describe('no log when logging is disabled', () => {
    let log2;

    /*
     * Remove the log package from the require cache and re-require it
     * this will cause the code inside to be re-ran so we can verify that
     * the ENABLE_AUTH_LOGGING variable works properly.
     */
    before(() => {
      delete require.cache[require.resolve('../dist/logger')];
      process.env.ENABLE_AUTH_LOGGING = false;
      log2 = require('../dist/logger').default;
    });

    it('should not log with .error', () => {
      log2.error('test log.error');
      expect(console.log.called).to.equal(false);
    });

    it('should not log with .warn', () => {
      log2.warn('test log.warn');
      expect(console.log.called).to.equal(false);
    });

    it('should not log with .success', () => {
      log2.success('test log.success');
      expect(console.log.called).to.equal(false);
    });

    it('should not log with .info', () => {
      log2.info('test log.info');
      expect(console.log.called).to.equal(false);
    });

    it('should not log with .plain', () => {
      log2.plain('test log.plain');
      expect(console.log.called).to.equal(false);
    });
  });
});

describe('Cirrus Ping Module', () => {
  describe('#authenticate', () => {
    it('should exist', () => {
      expect(auth.authenticate).to.not.equal(undefined);
    });

    it('should add middleware to express', async () => {
      sinon.spy(app, 'use');
      await auth.authenticate(app);

      expect(app.use.calledWith(auth.authMiddleware)).to.equal(true);
      app.use.restore();
    });
  });

  describe('#ignore', () => {
    it('should accept an array as a parameter', () => {
      const returned = auth.ignore(['test', 'one', 'two']);

      expect(returned.indexOf('test')).to.not.equal(-1);
      expect(returned.indexOf('one')).to.not.equal(-1);
      expect(returned.indexOf('two')).to.not.equal(-1);
    });

    it('should accept multiple parameters', () => {
      const returned = auth.ignore('foo', 'bar', 'baz');

      expect(returned.indexOf('foo')).to.not.equal(-1);
      expect(returned.indexOf('bar')).to.not.equal(-1);
      expect(returned.indexOf('baz')).to.not.equal(-1);
    });
  });

  describe('#authMiddleware', () => {
    it('should invoke next() if path is in ignored routes', () => {
      let invoked = false;

      auth.ignore('/ignored');

      const ensureLogin = ensureLoggedIn();

      const req = { session: {}, path: '/ignored' };
      const res = {};
      const next = () => invoked = true;

      auth.authMiddleware(req, res, next);

      const spy = sinon.spy(ensureLogin);

      expect(invoked).to.equal(true);
      expect(spy.called).to.equal(false);
    });

    it('should not redirect an authenticated user', () => {
      let redirected = false;

      const req = { session: { isAuthed: true }, originalUrl: '/', isAuthenticated: () => true };
      const res = { redirect: () => redirected = true };

      auth.authMiddleware(req, res, () => {});

      expect(redirected).to.equal(false);
    });
  });

  describe('/auth/userid', () => {
    it('should respond with json', (done) => {
      request(app)
        .get('/auth/userid')
        .set('Accept', 'application/json')
        .expect('Content-Type', /json/)
        .expect(200)
        .then((response) => {
          expect(response.body).to.have.own.property('userid');
          done();
        });
    });
  });

  describe('/login', () => {
    let testSession;

    before(() => {
      testSession = session(app);
    });

    it('should redirect user to federation server', (done) => {
      testSession
        .get('/login')
        .expect(302)
        .then((response) => {
          const urlParts = url.parse(response.headers.location, true);
          expect(urlParts.hostname).to.equal('federate-qa.xh1.lilly.com');
          expect(urlParts.query.scope).to.equal('openid auth_web');
          done();
        });
    });

    it('should fetch user details from tokenset', (done) => {
      const fakeTokenSet = {
        expires_in: NaN,
        state: '/login',
        claims: () => ({
          sub: '123456',
          name: 'John Doe',
          admin: true,
          iat: 1516239022,
          iss: 'https://federate-qa.xh1.lilly.com',
          aud: 'sample-clientid',
          exp: '9987654321',
        }),
        userinfo: {},
        sub: '123456',
      };
      const doneCallback = (_, tokenSet) => {
        expect(tokenSet.sub).to.equal('123456');
        expect(tokenSet.state).to.equal('/login');
        done();
      };
      const authCallBack = auth.authCallback;
      authCallBack(fakeTokenSet, doneCallback);
    });
  });

  describe('/logout', () => {
    // mock authenticating the user to test the logout function
    before(() => {
      passport.use('oidc', new MockStrategy());

      return agent
        .get('/login');
    });

    it('should log out user and redirect to correct url', (done) => {
      sinon.spy(IncomingMessage.prototype, 'logout');

      agent
        .get('/logout')
        .expect(302)
        .then((response) => {
          expect(response.headers.location).to.equal(afterLogoutUrl);
          expect(IncomingMessage.prototype.logout.called).to.equal(true);
          done();
        });
    });
  });

  describe(openidCallbackPath, () => {
    it('should send contents of authClientSide.html', (done) => {
      request(app)
        .get(openidCallbackPath)
        .expect(200)
        .then((response) => {
          expect(response.text).to.equal(fs.readFileSync(path.join(__dirname, '..', 'dist', 'authClientSide.html'), 'utf8'));
          done();
        });
    });
  });
});
