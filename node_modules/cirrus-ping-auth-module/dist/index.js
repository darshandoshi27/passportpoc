"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ignore = exports.authenticate = exports.authCallback = exports.authMiddleware = exports.discoverIssuerWithRetries = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _connectEnsureLogin = require("connect-ensure-login");

var _openidClient = require("openid-client");

var _passport = _interopRequireDefault(require("passport"));

var _endpoints = require("./endpoints");

var _util = require("./util");

var _logger = _interopRequireDefault(require("./logger"));

var OPENID_ISSUER = process.env.OPENID_ISSUER || 'https://federate-qa.xh1.lilly.com';
var ignoredRoutes = ['/login', _endpoints.useridCallbackPath, _endpoints.openidCallbackPath];
var authEnabled = (0, _util.checkEnvironment)();
var ensureLogin = (0, _connectEnsureLogin.ensureLoggedIn)();

if (_endpoints.afterLogoutUrl !== '/') {
  ignoredRoutes.push(_endpoints.afterLogoutUrl);
}

_passport["default"].serializeUser(function (user, cb) {
  cb(null, user);
});

_passport["default"].deserializeUser(function (user, cb) {
  cb(null, user);
});

var discoverIssuerWithRetries =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee2() {
    var retries,
        _args2 = arguments;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            retries = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : 5;
            return _context2.abrupt("return", new Promise(function (resolve, reject) {
              _openidClient.Issuer.discover(OPENID_ISSUER).then(function (issuer) {
                _logger["default"].info("Discovered issuer: ".concat(OPENID_ISSUER));

                resolve(issuer);
              })["catch"](
              /*#__PURE__*/
              (0, _asyncToGenerator2["default"])(
              /*#__PURE__*/
              _regenerator["default"].mark(function _callee() {
                var issuer;
                return _regenerator["default"].wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        if (retries <= 0) {
                          _logger["default"].error('Could not discover OpenID issuer!');

                          reject(new Error('Could not discover OpenID issuer'));
                        } else {
                          _logger["default"].info('Could not discover OpenID issuer, retrying...');

                          issuer = discoverIssuerWithRetries(retries - 1);
                          resolve(issuer);
                        }

                      case 1:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              })));
            }));

          case 2:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function discoverIssuerWithRetries() {
    return _ref.apply(this, arguments);
  };
}();
/**
 * middleware that authenticates the express router
 * @param  {Object}   req  request object from express router
 * @param  {Object}   res  response object from express router
 * @param  {Function} next function to move on to the next bit of middleware
 */


exports.discoverIssuerWithRetries = discoverIssuerWithRetries;

var authMiddleware =
/*#__PURE__*/
function () {
  var _ref3 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee3(req, res, next) {
    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (!(!authEnabled || ignoredRoutes.includes(req.path))) {
              _context3.next = 4;
              break;
            }

            // pass through to next request
            _logger["default"].info("Serving ".concat(req.path, " to verified user"));

            Object.keys(req.query || {}).filter(function (key) {
              return key !== 'id_token';
            }).forEach(function (key) {
              return _logger["default"].info("Param ".concat(key, ": ").concat(req.query[key]));
            });
            return _context3.abrupt("return", next());

          case 4:
            return _context3.abrupt("return", ensureLogin(req, res, next));

          case 5:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function authMiddleware(_x, _x2, _x3) {
    return _ref3.apply(this, arguments);
  };
}();
/**
 * Handles the callback for the Passport authentication strategy
 * @param {Object} tokenSet Tokenset returned from the Passport strategy
 * @param {Function} done Passport-provided callback
 */


exports.authMiddleware = authMiddleware;

var authCallback = function authCallback(tokenSet, done) {
  _logger["default"].info("User has been authenticated: ".concat(tokenSet.claims.sub));

  tokenSet.claims = tokenSet.claims();
  tokenSet.sub = tokenSet.claims.sub;
  tokenSet.userinfo = {};
  return done(null, tokenSet);
};
/**
 * Adds middlewares to the router to handle auth
 * Adds our custom authMiddle to an express router
 * @param  {Router} router Express Router/App
 */


exports.authCallback = authCallback;

var authenticate =
/*#__PURE__*/
function () {
  var _ref4 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee4(router) {
    var openidIssuer, client, params;
    return _regenerator["default"].wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            // this will ensure heroku gets the correct protocol
            router.set('trust proxy', true); // set up any middleware that we want the user to have access to, unauthenticated

            (0, _endpoints.applyMiddleware)(router, authEnabled, authMiddleware);

            if (authEnabled) {
              _context4.next = 4;
              break;
            }

            return _context4.abrupt("return", router);

          case 4:
            _context4.next = 6;
            return discoverIssuerWithRetries()["catch"](function () {
              _logger["default"].error("Could not discover issuer: ".concat(OPENID_ISSUER));

              _logger["default"].error('Check that you have spelled the URL correctly, and that the internet is up.');

              process.exit(1);
            });

          case 6:
            openidIssuer = _context4.sent;
            client = new openidIssuer.Client({
              client_id: process.env.OPENID_CLIENT_ID
            });
            params = {
              response_type: 'id_token',
              scope: 'openid auth_web'
            };

            _passport["default"].use('oidc', new _openidClient.Strategy({
              client: client,
              params: params
            }, authCallback));

            return _context4.abrupt("return", router);

          case 11:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function authenticate(_x4) {
    return _ref4.apply(this, arguments);
  };
}();
/**
 * Adds routes to the list of ignored routes
 */


exports.authenticate = authenticate;

var ignore = function ignore() {
  if (Array.isArray(arguments.length <= 0 ? undefined : arguments[0])) {
    ignoredRoutes.push.apply(ignoredRoutes, (0, _toConsumableArray2["default"])(arguments.length <= 0 ? undefined : arguments[0]));
  } else {
    ignoredRoutes.push.apply(ignoredRoutes, arguments);
  }

  return ignoredRoutes;
};

exports.ignore = ignore;
//# sourceMappingURL=index.js.map
