import { ensureLoggedIn } from 'connect-ensure-login';
import { Strategy, Issuer } from 'openid-client';
import passport from 'passport';

import {
  applyMiddleware,
  openidCallbackPath,
  useridCallbackPath,
  afterLogoutUrl,
} from './endpoints';

import { checkEnvironment } from './util';
import log from './logger';

const OPENID_ISSUER = process.env.OPENID_ISSUER || 'https://federate-qa.xh1.lilly.com';

const ignoredRoutes = ['/login', useridCallbackPath, openidCallbackPath];
const authEnabled = checkEnvironment();
const ensureLogin = ensureLoggedIn();

if (afterLogoutUrl !== '/') {
  ignoredRoutes.push(afterLogoutUrl);
}

passport.serializeUser((user, cb) => {
  cb(null, user);
});

passport.deserializeUser((user, cb) => {
  cb(null, user);
});

export const discoverIssuerWithRetries = async (retries = 5) => new Promise((resolve, reject) => {
  Issuer.discover(OPENID_ISSUER).then((issuer) => {
    log.info(`Discovered issuer: ${OPENID_ISSUER}`);
    resolve(issuer);
  }).catch(async () => {
    if (retries <= 0) {
      log.error('Could not discover OpenID issuer!');
      reject(new Error('Could not discover OpenID issuer'));
    } else {
      log.info('Could not discover OpenID issuer, retrying...');
      const issuer = discoverIssuerWithRetries(retries - 1);
      resolve(issuer);
    }
  });
});

/**
 * middleware that authenticates the express router
 * @param  {Object}   req  request object from express router
 * @param  {Object}   res  response object from express router
 * @param  {Function} next function to move on to the next bit of middleware
 */
export const authMiddleware = async (req, res, next) => {
  // allow a user through if we've disabled auth or they've ignored a route
  if (!authEnabled || ignoredRoutes.includes(req.path)) {
    // pass through to next request
    log.info(`Serving ${req.path} to verified user`);

    Object.keys(req.query || {})
      .filter((key) => key !== 'id_token')
      .forEach((key) => log.info(`Param ${key}: ${req.query[key]}`));

    return next();
  }

  return ensureLogin(req, res, next);
};

/**
 * Handles the callback for the Passport authentication strategy
 * @param {Object} tokenSet Tokenset returned from the Passport strategy
 * @param {Function} done Passport-provided callback
 */
export const authCallback = (tokenSet, done) => {
  log.info(`User has been authenticated: ${tokenSet.claims.sub}`);
  tokenSet.claims = tokenSet.claims();
  tokenSet.sub = tokenSet.claims.sub;
  tokenSet.userinfo = {};
  return done(null, tokenSet);
};

/**
 * Adds middlewares to the router to handle auth
 * Adds our custom authMiddle to an express router
 * @param  {Router} router Express Router/App
 */
export const authenticate = async (router) => {
  // this will ensure heroku gets the correct protocol
  router.set('trust proxy', true);

  // set up any middleware that we want the user to have access to, unauthenticated
  applyMiddleware(router, authEnabled, authMiddleware);

  if (!authEnabled) {
    return router;
  }

  const openidIssuer = await discoverIssuerWithRetries()
    .catch(() => {
      log.error(`Could not discover issuer: ${OPENID_ISSUER}`);
      log.error('Check that you have spelled the URL correctly, and that the internet is up.');
      process.exit(1);
    });

  const client = new openidIssuer.Client({
    client_id: process.env.OPENID_CLIENT_ID,
  });

  const params = {
    response_type: 'id_token',
    scope: 'openid auth_web',
  };

  passport.use('oidc', new Strategy({ client, params }, authCallback));

  return router;
};

/**
 * Adds routes to the list of ignored routes
 */
export const ignore = (...ignoredRoutesIn) => {
  if (Array.isArray(ignoredRoutesIn[0])) {
    ignoredRoutes.push(...ignoredRoutesIn[0]);
  } else {
    ignoredRoutes.push(...ignoredRoutesIn);
  }

  return ignoredRoutes;
};
